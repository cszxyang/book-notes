

## 链表中倒数第 k 个结点

**题目描述：** 输入一个链表，输出该链表中倒数第k个结点。

**解法：** 设置快慢指针 fast 和 slow，它们在一开始都指向链表头结点，在遍历链表时，将 fast 向前移动 k 个结点，然后以相同的速度移动这两个指针，fast 会在移动 listLength - k 步后到达链表尾结点，而此时 slow 抵达第 listLength - k 个即倒数第 k 个结点处。

```java
public ListNode findKthToTail(ListNode head, int k) {
    if (head == null || k == 0)   return null;

    ListNode fast = head, slow = head;
    for (int i = 0; i < k - 1; i++) {
        if (fast.next != null)
            fast = fast.next;
        else return null;
    }
    
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

## 访问单个节点的删除

**题目描述：** 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。给定待删除的节点，请执行删除操作，若该节点为尾节点，返回 false，否则返回 true。

**解法：** 直接将后继结点的数据复制到当前结点，然后删除这个后继结点。需要注意的是若待删除的结点为链表的尾结点，则问题无解。

```java
public boolean removeNode(ListNode node) {
    if (node == null || node.next == null)    return false;
    ListNode next = node.next;
    node.val = next.val;
    node.next = next.next;
    return true;
}
```

## 链表分割

**题目描述：** 编写代码，以给定值 x 为基准将链表分割成两部分，所有小于 x 的结点排在大于或等于 x 的结点之前

给定一个链表的头指针，请返回重新排列后的链表的头指针。注意：分割以后保持原来的数据顺序不变。

**解法：** 直接创建两个链表，一个存放小于 x 的元素，另一个存放大于或等于 x 的元素。在迭代链表时，为了维护原结点的顺序，采用尾插法将元素插入 before 或 after 链表，遍历完成后合并这两个链表。

```java
public ListNode partition(ListNode node, int x) {
    ListNode beforeStart = null, beforeEnd = null;
    ListNode afterStart = null, afterEnd = null;

    while (node != null) {
        ListNode next = node.next;
        node.next = null;
        if (node.val < x) {
            if (beforeStart == null) {
                beforeStart = node;
            } else {
                beforeEnd.next = node;
            }
            beforeEnd = node;
        } else {
            if (afterStart == null) {
                afterStart = node;
            } else {
                afterEnd.next = node;
            }
            afterEnd = node;
        }
        node = next;
    }

    if (beforeStart == null) {
        return afterStart;
    }

    // 合并前后链表
    beforeEnd.next = afterStart;
    return beforeStart;
}
```

## 链式 A+B

**题目描述：** 有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果。

**解法：** 将两个链表的结点逐一相加，如有进位则将之传入下一对结点。

```java
public class Solution {
    public ListNode addLists(ListNode la, ListNode lb) {
        return addLists(la, lb, 0);
    }

    private ListNode addLists(ListNode la, ListNode lb, int carry) {
        if (la == null && lb == null && carry == 0)
            return null;

        int val = carry;
        if (la != null) {
            val += la.val;
        }
        if (lb != null) {
            val += lb.val;
        }

        ListNode res = new ListNode(val % 10);
        res.next = addLists(la == null ? null : la.next,
                            lb == null ? null : lb.next,
                            val >= 10 ? 1 : 0);
        return res;
    }
}
```

## 回文链表

**题目描述：** 请编写一个函数，检查链表是否为回文。

**解法：** 使用快慢指针法访问链表，在迭代的每一步中，将 slow 指针的数据入栈，在 fast 抵达链表尾部时，slow 刚好位于链表的中间位置，至此栈中反序地存放了链表的前半部分的所有节点。接下来只需使用 slow 迭代链表的余下结点，每次迭代时比较当前结点和栈顶元素，若完成迭代时比较结果完全相同，则该链表尾回文链表。

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    Stack<Integer> stack = new Stack<>();

    while (fast != null && fast.next != null) {
        stack.push(slow.val);
        slow = slow.next;
        fast = fast.next.next;
    }

    // 奇数个元素，跳过中间元素
    if (fast != null) {
        slow = slow.next;
    }

    while (slow != null) {
        if (stack.pop() != slow.val)
            return false;
        slow = slow.next;
    }
    return true;
}
```

